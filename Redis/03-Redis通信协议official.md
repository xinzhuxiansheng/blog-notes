## Redis通信协议

>本篇blog，参考官方文档翻译得来（ChatGPT翻译）  

# Redis序列化协议 (RESP) 规范

Redis客户端使用一种名为**RESP** (REdis Serialization Protocol，Redis序列化协议)的协议与Redis服务器进行通信。虽然这种协议是专门为Redis设计的，但它也可以用于其他客户端-服务器软件项目。  

RESP是以下几个方面的妥协：  

* 易于实现。    
* 解析速度快。  
* 方便人类阅读。    

RESP可以序列化不同的数据类型，如整数，字符串和数组。它还有一个专门表示错误的类型。请求是作为字符串数组从客户端发送到Redis服务器的，这些字符串表示要执行的命令的参数。Redis以命令特定的数据类型进行回复。    

RESP是二进制安全的，因为它使用前缀长度来传输大量数据，所以不需要处理从一个进程传输到另一个进程的大量数据。  

注意：这里概述的协议仅用于客户端-服务器通信。Redis集群使用另一种二进制协议来在节点之间交换消息。    

## 网络层

客户端通过创建一个到6379端口的TCP连接来连接到Redis服务器。  

尽管技术上来说RESP不仅仅限于TCP，但在Redis的上下文中，该协议只用于TCP连接（或类似于Unix套接字的流式连接）。 

## 请求-响应模型    

Redis接受由不同参数组成的命令。一旦收到命令，它将进行处理并将回复发送回客户端。 

这是最简单的模型；然而，有两个例外：    

* Redis支持流水线（在本文档后面有介绍）。所以客户端可以一次发送多个命令，稍后再等待回复。   
* 当一个Redis客户端订阅了一个发布/订阅频道时，协议更改了语义，变成了一个*推送*协议。客户端不再需要发送命令，因为服务器将自动将新的消息发送给客户端（对于客户端订阅的频道），一旦它们被接收。    

排除这两个例外，Redis协议是一个简单的请求-响应协议。        

## RESP协议描述

RESP协议在Redis 1.2中引入，但它在Redis 2.0中成为了与Redis服务器通信的标准方式。     
这是你在Redis客户端应该实现的协议。 

RESP实际上是一个序列化协议，支持以下数据类型：简单字符串、错误、整数、大块字符串和数组。    

Redis使用RESP作为请求-响应协议，方式如下：  

* 客户端将命令作为RESP数组的大块字符串发送到Redis服务器。   
* 服务器根据命令的实现以RESP类型之一回复。  

在RESP中，第一个字节决定了数据类型：    

* 对于**简单字符串**，回复的第一个字节是 "+"    
* 对于**错误**，回复的第一个字节是 "-"  
* 对于**整数**，回复的第一个字节是 ":"  
* 对于**大块字符串**，回复的第一个字节是 "$"    
* 对于**数组**，回复的第一个字节是 "`*`"    

RESP可以使用大块字符串或数组的特殊变体来表示空值，如后面所述。  

在RESP中，协议的不同部分总是以"\r\n"（CRLF）结束。  


## RESP简单字符串

简单字符串按照以下方式编码：一个加号字符，后面跟着一个不能包含CR或LF字符的字符串（不允许有换行符），并以CRLF（即"\r\n"）结尾。  

简单字符串用于以最小的开销传输非二进制安全的字符串。例如，许多Redis命令在成功时仅回复"OK"。RESP简单字符串以以下5个字节编码：    
```shell
"+OK\r\n"
```

为了发送二进制安全的字符串，请改用RESP大块字符串。  

当Redis以简单字符串回复时，客户端库应该回应一个字符串，这个字符串由'+'后的第一个字符组成，直到字符串的末尾，不包括最后的CRLF字节。  

## RESP错误

RESP有一个专门的错误数据类型。它们类似于RESP简单字符串，但第一个字符是减号'-'而不是加号。RESP中简单字符串和错误之间的真正区别在于，客户端将错误视为异常，而构成错误类型的字符串本身就是错误消息。   

基本格式是：    
```shell
"-Error message\r\n"
```

只有当出错时，才会发送错误回复，例如，如果您试图对错误的数据类型执行操作，或者命令不存在。当客户端收到错误回复时，应该引发异常。    

以下是错误回复的示例：  
```shell
-ERR unknown command 'helloworld'
-WRONGTYPE Operation against a key holding the wrong kind of value
```

"-"后的第一个单词，直到第一个空格或换行符，表示返回的错误类型。这只是Redis使用的一种约定，不是RESP错误格式的一部分。    

例如，`ERR`是通用错误，而`WRONGTYPE`是更具体的错误，表示客户端试图对错误的数据类型执行操作。这称为**错误前缀**，是一种让客户端在不检查确切错误消息的情况下理解服务器返回的错误类型的方式。  

客户端实现可以为不同的错误返回不同类型的异常，或者通过直接将错误名称作为字符串提供给调用者，提供一种通用的方式来捕获错误。  

然而，这样的特性不应被视为至关重要，因为它很少有用，一个有限的客户端实现可能只返回一个通用的错误条件，如`false`。       

## RESP整数

这种类型仅仅是一个表示整数的以CRLF结尾的字符串，以":"字节为前缀。例如，":0\r\n" 和 ":1000\r\n" 是整数回复。 

许多Redis命令返回RESP整数，如`INCR`，`LLEN`和`LASTSAVE`。   

返回的整数没有特殊的含义。对于`INCR`，它只是一个增量数字；对于`LASTSAVE`，它是一个UNIX时间，等等。然而，返回的整数保证在有符号64位整数的范围内。    

整数回复也用于返回真或假。例如，像`EXISTS`或`SISMEMBER`这样的命令将返回1表示真，返回0表示假。   

其他像`SADD`，`SREM`，和`SETNX`这样的命令，如果操作实际上被执行了，将返回1；否则返回0。 

以下命令将回复一个整数：`SETNX`，`DEL`，`EXISTS`，`INCR`，`INCRBY`，`DECR`，`DECRBY`，`DBSIZE`，`LASTSAVE`，`RENAMENX`，`MOVE`，`LLEN`，`SADD`，`SREM`，`SISMEMBER`，`SCARD`。  

## RESP大块字符串

大块字符串用于表示长度最大为512MB的单个二进制安全字符串。   

大块字符串按照以下方式编码：    

* 一个"$"字节，后跟组成字符串的字节数（一个前缀长度），以CRLF结束。 
* 实际的字符串数据。    
* 最后的CRLF。  

所以字符串"hello"被编码如下：   
```shell
"$5\r\nhello\r\n"
```

一个空字符串被编码为：  
```shell
"$0\r\n\r\n"
```

RESP大块字符串也可以用来表示值不存在，使用特殊的格式表示Null值。在这种格式中，长度是-1，没有数据。Null被表示为：    
```shell
"$-1\r\n"
```

这被称为**Null大块字符串**。    

当服务器回复一个Null大块字符串时，客户端库API应返回一个nil对象，而不是一个空字符串。例如，Ruby库应返回'nil'，而C库应返回NULL（或在回复对象中设置一个特殊标志）。    

## RESP数组

客户端使用RESP数组向Redis服务器发送命令。同样，某些返回元素集合给客户端的Redis命令，使用RESP数组作为他们的回复。一个例子是`LRANGE`命令，它返回列表的元素。  

RESP数组按照以下格式发送：  

* 一个`*`字符作为第一个字节，后跟数组中的元素数量作为一个十进制数，然后跟着CRLF。   
* 数组中每个元素的一个额外的RESP类型。  

所以一个空数组就是下面这样：    
```shell
"*0\r\n"
```

而  

两个RESP大块字符串"hello"和"world"的数组被编码为：  
```shell
"*2\r\n$5\r\nhello\r\n$5\r\nworld\r\n"
```

你可以看到，在数组的前缀`*<count>CRLF`部分之后，组成数组的其他数据类型就是一个接一个地串联在一起。例如，三个整数的数组被编码如下：  
```shell
"*3\r\n:1\r\n:2\r\n:3\r\n"
```

数组可以包含混合类型，所以元素不必是同一类型。例如，一个包含四个整数和一个大块字符串的列表可以被编码如下：  
```shell
*5\r\n
:1\r\n
:2\r\n
:3\r\n
:4\r\n
$5\r\n
hello\r\n
```

（为了清晰起见，回复被分割成多行）。    

服务器发送的第一行是`*5\r\n`，以指定将有五个回复。然后发送每个构成多大块回复项目的回复。    

Null数组也存在，它是指定Null值的另一种方式（通常使用Null大块字符串，但出于历史原因，我们有两种格式）。  

例如，当`BLPOP`命令超时时，它返回一个Null数组，计数为-1，如下例：   
```shell
"*-1\r\n"
```

当Redis回复一个Null数组时，客户端库API应返回一个null对象，而不是一个空数组。这是必要的，以区别空列表和不同的条件（例如`BLPOP`命令的超时条件）。 

RESP中可能有嵌套的数组。例如，一个包含两个数组的嵌套数组被编码如下：    
```shell
*2\r\n
*3\r\n
:1\r\n
:2\r\n
:3\r\n
*2\r\n
+Hello\r\n
-World\r\n
```

（格式被分割成多行以便于阅读）。    

上述的RESP数据类型编码了一个两元素数组，由一个包含三个整数（1，2，3）的数组和一个由简单字符串和错误组成的数组组成。 

## 数组中的Null元素

数组的单个元素可能是Null。这在Redis回复中被用来表示这些元素是缺失的，而不是空字符串。当SORT命令与GET _pattern_选项一起使用时，如果指定的键缺失，就可能发生这种情况。以下是一个包含Null元素的数组回复示例：  
```shell
*3\r\n
$5\r\n
hello\r\n
$-1\r\n
$5\r\n
world\r\n
```

第二个元素是Null。客户端库应该返回类似这样的内容：  
```shell
["hello",nil,"world"]
```

请注意，这并不是对前面几节所说内容的例外，而是进一步指定协议的示例。    

## 向Redis服务器发送命令

现在你已经熟悉了RESP序列化格式，你可以用它来帮助编写Redis客户端库。我们可以进一步指定客户端和服务器之间的交互方式： 

* 客户端发送一个只包含大块字符串的RESP数组到Redis服务器。   
* Redis服务器回复客户端，发送任何有效的RESP数据类型作为回复。   

所以例如，典型的交互可能如下。  

客户端发送命令**LLEN mylist**，以获取存储在键*mylist*处的列表的长度。然后服务器以整数回复，如下例所示（C:是客户端，S:是服务器）。   
```shell
C: *2\r\n
C: $4\r\n
C: LLEN\r\n
C: $6\r\n
C: mylist\r\n

S: :48293\r\n
```

像往常一样，我们以换行符分隔协议的不同部分以简化，但实际的交互是客户端整体发送`*2\r\n$4\r\nLLEN\r\n$6\r\nmylist\r\n`。  

## 多命令和管道化

客户端可以使用同一连接来发出多个命令。支持管道化，所以客户端可以通过一次写操作发送多个命令，无需在发出下一个命令前读取上一个命令的服务器回复。所有的回复都可以在最后读取。  

更多信息，请参阅[Pipelining](/topics/pipelining)。  

## 内联命令

有时你可能需要向Redis服务器发送命令，但只有`telnet`可用。虽然Redis协议简单易实现，但在交互式会话中使用并不理想，而`redis-cli`可能并不总是可用。因此，Redis还接受**内联命令**格式的命令。    

以下是使用内联命令的服务器/客户端聊天示例（服务器聊天以S:开始，客户端聊天以C:开始）：   
```shell
C: PING
S: +PONG
```

以下是一个返回整数的内联命令示例：  
```shell
C: EXISTS some
S: :0
```

基本上，你在telnet会话中写入由空格分隔的参数。因为没有命令以`*`开始，而这是在统一请求协议中使用的，所以Redis能够检测到这种条件并解析你的命令。  

## Redis协议的高性能解析器

虽然Redis协议是人类可读的且易于实现，但其性能可以与二进制协议相媲美。   

RESP使用前缀长度来传输大块数据，所以永远不需要为了寻找特殊字符（如JSON）而扫描有效载荷，也不需要将需要发送到服务器的有效载荷加引号。    

大块和多块长度可以用执行每个字符单一操作的代码进行处理，同时扫描CR字符，如下面的C代码： 

```
#include <stdio.h>

int main(void) {
    unsigned char *p = "$123\r\n";
    int len = 0;

    p++;
    while(*p != '\r') {
        len = (len*10)+(*p - '0');
        p++;
    }

    /* 现在p指向'\r'，并且长度在bulk_len中。 */
    printf("%d\n", len);
    return 0;
}
```

在识别出第一个CR之后，可以跳过它以及后面的LF，不进行任何处理。然后可以使用一个不以任何方式检查有效载荷的单一读取操作来读取大块数据。最后，丢弃剩余的CR和LF字符，不进行任何处理。    

虽然在性能上可以与二进制协议相比，但Redis协议在大多数高级语言中的实现要简单得多，减少了客户端软件中的错误数量。 


refer
1.https://redis.io/docs/reference/protocol-spec/