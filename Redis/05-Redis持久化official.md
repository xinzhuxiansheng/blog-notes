## Redis持久化

>本篇blog，参考官方文档翻译得来（ChatGPT翻译）  

持久性是指将数据写入到耐用存储，例如固态硬盘（SSD）。Redis 提供了一系列持久性选项。这些包括：   

* **RDB**（Redis 数据库）：RDB 持久性在指定的时间间隔内执行你的数据集的时间点快照。 
* **AOF**（仅追加文件）：AOF 持久性记录服务器收到的每一个写操作。这些操作随后可以在服务器启动时再次播放，从而重建原始数据集。命令是使用与 Redis 协议本身相同的格式进行记录的。  
* **无持久性**：你可以完全禁用持久性。这有时在缓存时使用。  
* **RDB + AOF**：你也可以在同一实例中同时使用 AOF 和 RDB。  

如果你不想思考这些不同持久性策略之间的权衡，你可能会想考虑 [Redis 企业版的持久性选项](https://docs.redis.com/latest/rs/databases/configure/database-persistence/)，这些选项可以使用 UI 预先配置。   

如果你想了解更多关于如何评估你的 Redis 持久性策略的信息，请继续阅读。   

## RDB 的优点

* RDB 是一个非常紧凑的单文件时间点表示你的 Redis 数据。RDB 文件非常适合备份。例如，你可能想要每小时归档一次你的 RDB 文件，保留最近24小时的文件，并且每天保存一次 RDB 快照，保留30天。这使你能够在灾难情况下轻松地恢复数据集的不同版本。 
* RDB 非常适合灾难恢复，因为它是一个可以被传输到远程数据中心或上传到 Amazon S3 的单一紧凑文件（可能是加密的）。
* RDB 最大化了 Redis 的性能，因为 Redis 父进程为了持久化所需做的唯一工作就是生成一个子进程，子进程将做其他所有事情。父进程永远不会进行磁盘 I/O 或类似操作。 
* 相比于 AOF，RDB 允许在大数据集下更快的重启。  
* 在复制品上，RDB 支持[重启和故障转移后的部分重新同步](https://redis.io/topics/replication#partial-resynchronizations-after-restarts-and-failovers)。   

## RDB 的缺点

* 如果你需要尽量减少 Redis 停止工作时（例如电力中断后）数据丢失的可能性，那么 RDB 不是一个好选择。你可以配置不同的 *保存点* 来产生一个 RDB（例如在数据集至少进行 100 次写入操作并过去五分钟后，你可以设定多个保存点）。然而，你通常每五分钟或更长时间创建一个 RDB 快照，所以如果 Redis 因任何原因在没有正确关闭的情况下停止工作，你应该准备好可能会丢失最近几分钟的数据。   
* RDB 需要经常 fork() 以便使用子进程将数据持久化到磁盘。如果数据集很大，fork() 可能会消耗大量时间，并可能导致 Redis 在几毫秒或甚至一秒内停止为客户端提供服务，如果数据集非常大且 CPU 性能不佳。AOF 也需要 fork()，但频率较低，你可以调整你想要多久重写你的日志，而不会对持久性产生任何权衡。    

## AOF 的优点

* 使用 AOF 的 Redis 更具有持久性：你可以有不同的 fsync 策略：完全不 fsync，每秒一次 fsync，每个查询一次 fsync。默认的每秒 fsync 策略下，写性能仍然很好。fsync 是由后台线程执行的，主线程会尽量在没有 fsync 在进行时执行写操作，因此你只可能丢失一秒钟的写操作。 
* AOF 日志是一个只追加日志，因此不会有寻址问题，也不会在电力中断时出现损坏问题。即使日志因某种原因（磁盘满或其他原因）以半写入命令结束，redis-check-aof 工具也能轻易修复它。    
* 当 AOF 变得过大时，Redis 能够自动在后台重写 AOF。重写是完全安全的，因为在 Redis 继续向旧文件追加的同时，会产生一个完全新的文件，其中包含创建当前数据集所需的最小操作集，一旦这个第二个文件准备就绪，Redis 就会交换这两个文件，并开始向新的文件追加。  
* AOF 包含一个易于理解和解析的格式的所有操作的日志，一个接一个。你甚至可以轻易导出一个 AOF 文件。例如，即使你已经不小心使用 `FLUSHALL` 命令清除了所有内容，只要在此期间没有进行日志的重写，你仍然可以通过停止服务器，删除最新的命令，然后再次启动 Redis 来保存你的数据集。  

## AOF 的缺点

* 对于相同的数据集，AOF 文件通常比等效的 RDB 文件大。   
* AOF 可能比 RDB 慢，具体取决于 fsync 策略。通常情况下，设置 fsync 为 *每秒一次* 的性能仍然非常高，如果禁用 fsync，即使在高负载下，其速度也应该与 RDB 完全相同。尽管如此，即使在巨大的写负载情况下，RDB 仍能提供关于最大延迟的更多保证。    

**Redis < 7.0**

* 如果在重写过程中有写入数据库的操作，AOF 可能会使用大量的内存（这些写入操作会在内存中缓存，并在最后写入新的 AOF）。    
* 在重写期间到达的所有写命令都会被写入磁盘两次。    
* Redis 可能会在重写结束时冻结写入并将这些写命令 fsync 到新的 AOF 文件。    

那我应该使用哪个呢？    
---

如果你希望得到与 PostgreSQL 可以为你提供的数据安全性相当的程度，那么一般的指示是你应该使用两种持久化方法。  

如果你非常关心你的数据，但仍然可以忍受在灾难情况下失去几分钟的数据，你可以只使用 RDB。  

有许多用户只使用 AOF，但我们并不鼓励这种做法，因为有时候有一个 RDB 快照是一个很好的主意，可以用来做数据库备份，快速重启，并在 AOF 引擎出现 bug 的情况下使用。   

以下的部分将进一步详细说明这两种持久化模型。    

## 快照

默认情况下，Redis 在磁盘上保存数据集的快照，保存在一个名为 `dump.rdb` 的二进制文件中。你可以配置 Redis，让它在数据集发生至少 M 次更改后的 N 秒内保存数据集，或者你可以手动调用 `SAVE` 或 `BGSAVE` 命令。    

例如，这个配置将让 Redis 在至少 1000 个键更改后自动将数据集每 60 秒转储到磁盘： 
```
save 60 1000
```

这种策略被称为 _快照_。 

### 它是如何工作的

每当 Redis 需要将数据集转储到磁盘时，会发生以下情况：   

* Redis [分叉](http://linux.die.net/man/2/fork)。现在我们有了一个子进程和一个父进程。   

* 子进程开始将数据集写入临时的 RDB 文件。   

* 当子进程完成新的 RDB 文件的写入时，它会替换旧的文件。 

这种方法允许 Redis 从写时复制 (copy-on-write) 语义中受益。  

## 附加文件

快照技术在持久性上不是很强。如果运行 Redis 的计算机停机，电源线出问题，或者你不小心对你的实例执行了 `kill -9`，写入 Redis 的最新数据将丢失。虽然这对某些应用可能并不是什么大问题，但有些用例需要完全的持久性，在这些情况下，仅使用 Redis 的快照技术并不是一个可行的选择。   

_附加文件（Append-only file，AOF）_ 是 Redis 的一种替代方案，它提供了完全的持久性。这项功能在 1.1 版本中变得可用。  

你可以在你的配置文件中开启 AOF：    
```
appendonly yes
```

从现在开始，每次 Redis 接收到改变数据集的命令（例如 `SET`），它将会将它追加到 AOF。当你重新启动 Redis 时，它将重放 AOF 来重建状态。 

自从 Redis 7.0.0 版本开始，Redis 使用了多部分的 AOF 机制。也就是说，原来的单一 AOF 文件被分割成基础文件（最多一个）和增量文件（可能有多个）。基础文件代表 AOF [重写](#log-rewriting)时存在的初始数据（RDB 或 AOF 格式）的快照。增量文件包含自上一次创建基础 AOF 文件以来的增量更改。所有这些文件都放在一个单独的目录中，并通过清单文件进行追踪。    

### 日志重写

随着写入操作的执行，AOF 会变得越来越大。例如，如果你增加一个计数器100次，你将最终在你的数据集中得到一个包含最终值的键，但在你的 AOF 中会有100个条目。其中99个条目在重建当前状态时并不需要。 

重写是完全安全的。在 Redis 继续追加到旧文件的同时，会生成一个完全新的文件，其中包含创建当前数据集所需的最小操作集，一旦这个第二个文件准备好，Redis 就会切换这两个文件，并开始追加到新文件。 

所以，Redis 支持一个有趣的功能：它能够在不中断服务的情况下，在后台重建 AOF。无论何时你发出 `BGREWRITEAOF`，Redis 都会写入重建当前内存中的数据集所需的最短命令序列。如果你在使用 Redis 2.2，并且启用了 AOF，你需要不时地运行 `BGREWRITEAOF`。自 Redis 2.4 起，它能够自动触发日志重写（查看示例配置文件以获取更多信息）。 

自 Redis 7.0.0  

 起，当一个 AOF 重写被计划时，Redis 父进程会打开一个新的增量 AOF 文件以继续写入。子进程执行重写逻辑并生成一个新的基础 AOF。Redis 将使用一个临时清单文件来追踪新生成的基础文件和增量文件。当它们准备好时，Redis 将执行一个原子替换操作，使这个临时清单文件生效。为了避免在 AOF 重写重复失败和重试的情况下创建许多增量文件的问题，Redis 引入了 AOF 重写限制机制，以确保失败的 AOF 重写以越来越慢的速度进行重试。  

### 附加文件有多持久？

你可以配置 Redis 将 [`fsync`](http://linux.die.net/man/2/fsync) 数据到磁盘的次数。有三个选项：  

* `appendfsync always`：每次将新命令追加到 AOF 时执行 `fsync`。非常非常慢，但非常安全。注意，命令是在来自多个客户端或管道的一批命令执行后追加到 AOF 的，所以这意味着一个单独的写入和一个单独的 `fsync`（在发送回复之前）。  
* `appendfsync everysec`：每秒 `fsync` 一次。足够快（自 2.4 版本以来，可能和快照技术一样快），如果出现灾难，你可能会丢失 1 秒的数据。   
* `appendfsync no`：从不 `fsync`，只是将你的数据交给操作系统。这是最快也是最不安全的方法。通常情况下，这种配置下的 Linux 系统会每 30 秒刷新数据，但这取决于内核的具体调优。 

建议的（也是默认的）策略是每秒 `fsync` 一次。这既快又相对安全。`always` 策略在实践中非常慢，但它支持组提交，所以如果有多个并行写入，Redis 会试图执行单个 `fsync` 操作。 

### 如果我的 AOF 被截断，我应该怎么做？

有可能服务器在写 AOF 文件时崩溃，或者写入时 AOF 文件所在的卷已满。当这种情况发生时，AOF 仍然包含一致的数据，代表数据集的某个时点版本（如果使用默认的 AOF fsync 策略，可能会落后最多一秒），但 AOF 中的最后一个命令可能被截断。Redis 的最新主要版本将能够加载 AOF，只需丢弃文件中的最后一个格式不正确的命令。在这种情况下，服务器将发出如下日志：    

```
* 从 AOF 文件读取 RDB 前言...
* 读取剩余的 AOF 尾部...
# !!! 警告：在加载 AOF 文件时读取不足 !!!
# !!! 在偏移量 439 截断 AOF !!!
# 无论如何都已加载 AOF，因为已启用 aof-load-truncated
```

你可以更改默认配置，如果你愿意，可以强制 Redis 在这种情况下停止，但是默认配置是继续，无论文件中的最后一个命令是否格式良好，以保证在重启后的可用性。 

较旧的 Redis 版本可能无法恢复，可能需要以下步   

骤：    

* 备份你的 AOF 文件。   
* 使用随 Redis 一起提供的 `redis-check-aof` 工具修复原始文件：  

      $ redis-check-aof --fix <filename>

* 可选地使用 `diff -u` 检查两个文件之间的区别。 
* 使用修复后的文件重启服务器。  

### 如果我的 AOF 文件损坏了，我应该怎么办？

如果 AOF 文件不仅被截断，而且中间还有无效的字节序列，那么问题就更复杂了。Redis 会在启动时抱怨并终止：   

```
* 读取剩余的 AOF 尾部...
# 在读取附加文件时出现错误的文件格式：备份你的 AOF 文件，然后使用 ./redis-check-aof --fix <filename>
```

最好的做法是运行 `redis-check-aof` 实用程序，首先不带 `--fix` 选项，然后理解问题，跳转到文件中给定的偏移位置，看是否可以手动修复文件：AOF 使用与 Redis 协议相同的格式，很容易手动修复。否则，可能让该实用程序为我们修复文件，但在那种情况下，可能会丢弃从无效部分到文件末尾的所有 AOF 部分，如果损坏恰好发生在文件的初始部分，可能导致大量数据丢失。    

### 工作原理

日志重写使用了已经用于快照的相同的写时复制技巧。这是它的工作方式：  

**Redis >= 7.0**

* Redis [fork](http://linux.die.net/man/2/fork)，所以现在我们有一个子进程和一个父进程。 

* 子进程开始在一个临时文件中写新的基础 AOF。    

* 父进程打开一个新的增量 AOF 文件以继续写更新。如果重写失败，旧的基础和增量文件（如果有的话）加上这个新打开的增量文件代表了完整的更新数据集，所以我们是安全的。 

* 当子进程完成基础文件的重写时，父进程得到一个信号，并使用新打开的增量文件和子进程生成的基础文件来构建一个临时清单，并将其持久化。  

* 利润！现在 Redis 对清单文件进行原子交换，以使这个 AOF 重写的结果生效。Redis 还清理旧的基础文件和任何未使用的增量文件。    

**Redis < 7.0**

* Redis [fork](http://linux.die.net/man/2/fork)，所以现在我们有一个子进程和一个父进程。 

* 子进程开始在一个临时文件中写新的 AOF。    

* 父进程在内存缓冲区中累积所有新的更改（但同时它在旧的附加文件中写入新的更改，所以如果重写失败，我们是安全的）。    

* 当子进程完成文件的重写时，父进程得到一个信号，并将内存缓冲区追加到子进程生成的文件的末尾。    

* 现在 Redis 原子性 

地将新文件重命名为旧文件，并开始在新文件中追加新数据。  


### 如果我目前正在使用 dump.rdb 快照，我如何切换到 AOF？

在 2.0 版本和更高版本中执行此操作的程序有所不同，你可以猜到，自 Redis 2.2 以来，这个过程更为简单，完全不需要重启。  

**Redis >= 2.2**

* 备份你的最新 dump.rdb 文件。  
* 将这个备份转移到一个安全的地方。  
* 执行以下两个命令：    
  * `redis-cli config set appendonly yes`   
  * `redis-cli config set save ""`  
* 确保你的数据库包含与之前相同数量的键。    
* 确保写入正确地追加到附加文件中。  

第一个 CONFIG 命令启用了附加只文件（AOF）持久化。   

第二个 CONFIG 命令用于关闭快照持久化。这是可选的，如果你愿意，你可以同时启用这两种持久化方法。  

**重要**：记得编辑你的 redis.conf 文件以开启 AOF，否则当你重启服务器时，配置更改将丢失，服务器将再次以旧配置启动。  

**Redis 2.0**

* 备份你的最新 dump.rdb 文件。  
* 将这个备份转移到一个安全的地方。  
* 停止所有针对数据库的写入操作！    
* 执行 `redis-cli BGREWRITEAOF`。这将创建附加只文件。   
* 当 Redis 完成 AOF 转储时，停止服务器。    
* 编辑 redis.conf 文件并启用附加只文件持久化。  
* 重启服务器。  
* 确保你的数据库包含与切换前相同数量的键。  
* 确保写入正确地追加到附加文件中。  

## AOF 和 RDB 持久化之间的互动

Redis >= 2.4 确保在 RDB 快照操作已经在进行时，避免触发 AOF 重写，或者在 AOF 重写进行时，不允许 `BGSAVE`。这可以防止两个 Redis 后台进程同时进行大量的磁盘 I/O。  

当快照进行中，用户使用 `BGREWRITEAOF` 明确请求日志重写操作时，服务器将回复 OK 状态码，告诉用户操作已计划，一旦完成快照，重写将开始。    

如果同时启用了 AOF 和 RDB 持久化，并且 Redis 重启，将使用 AOF 文件来重构原始数据集，因为它保证是最完整的。  

## 备份 Redis 数据

在开始这个部分之前，请务必阅读以下语句：**确保备份你的数据库**。硬盘会损坏，云中的实例会消失等等：没有备份就意味着数据有可能消失到 /dev/null 中。   

Redis 非常友好地支持数据    

备份，因为你可以在数据库运行时复制 RDB 文件：一旦生成 RDB，就不会再修改，而在生成过程中，它使用临时名称，并仅在新快照完成时，使用 rename(2) 将其原子性地重命名为最终目的地。    

这意味着在服务器运行时复制 RDB 文件是完全安全的。我们建议如下操作： 

* 在你的服务器中创建一个 cron 任务，每小时在一个目录中创建 RDB 文件的快照，每天在另一个目录中创建快照。 
* 每次 cron 脚本运行时，确保调用 `find` 命令以确保过旧的快照被删除：例如，你可以保留最近 48 小时的每小时快照，以及一个或两个月的每日快照。确保以日期和时间信息命名快照。    
* 至少每天一次，确保将 RDB 快照传输到你的数据中心之外，或至少到运行你的 Redis 实例的物理机器之外。  

### 备份 AOF 持久化

如果你运行的 Redis 实例仅启用了 AOF 持久化，你仍然可以执行备份。        
自 Redis 7.0.0 开始，AOF 文件被分割成多个文件，这些文件位于由 `appenddirname` 配置确定的单个目录中。    
在正常操作期间，你只需要复制/打包这个目录中的文件就能实现备份。然而，如果在[重写](#log-rewriting)期间进行这样的操作，你可能会得到一个无效的备份。   
为解决这个问题，你必须在备份期间禁用 AOF 重写：

1. 关闭自动重写<br/>    
```
   `CONFIG SET` `auto-aof-rewrite-percentage 0`<br/>
   确保在此期间你不会手动启动重写（使用 `BGREWRITEAOF`）。
```
2. 使用<br/>    
```
   `INFO` `persistence`<br/>
   检查当前是否有重写在进行，并确认 `aof_rewrite_in_progress` 是 0。如果是 1，那么你需要等待重写完成。
```
3. 现在你可以安全地复制 `appenddirname` 目录中的文件。  
4. 完成后重新启用重写：<br/>    
```
   `CONFIG SET` `auto-aof-rewrite-percentage <prev-value>`
```

**注意：**如果你想最小化禁用 AOF 重写的时间，你可以在 `appenddirname` 中为文件创建硬链接（在上面的第3步），然后在创建硬链接后重新启用重写（第4步）。    
现在你可以复制/打包硬链接，并在完成后删除它们。这样做的原因是 Redis 保证只将内容追加到此目录中的文件，或者在必要时完全替换它们，所以在任何给定的时间点，内容应该是一致的。    

**注意：**如果你想处理在备份期间服务器重启的情况，并确保重启后不会自动开始重写，你可以更改上面的第1步，也通过 `CONFIG REWRITE` 持久化更新的配置。   
只要在完成后重新启用自动重写（第4步）并通过另一个 `CONFIG REWRITE` 持久化它。    

在 7.0.0 版本之前，备份 AOF 文件可以通过简单地复制 aof 文件完成（就像备份 RDB 快照一样）。文件可能缺少最后一部分，但 Redis 仍然能够加载它（参见前面关于[截断的 AOF 文件]    (#what-should-i-do-if-my-aof-gets-truncated)的部分）。      

    
## 灾难恢复 

在 Redis 的语境中，灾难恢复基本上与备份相同，只是增加了将这些备份转移到许多不同的外部数据中心的能力。这样，即使主数据中心    

出现影响 Redis 运行和生成快照的灾难性事件，数据也能得到保障。   

我们将审查最有趣的灾难恢复技术，它们的成本不会太高。    

* 亚马逊 S3 和其他类似的服务是实现你的灾难恢复系统的好方法。简单地将你每日或每小时的 RDB 快照以加密的形式传输到 S3。你可以使用 `gpg -c` （在对称加密模式下）加密你的数据。确保将你的密码存放在许多不同的安全地方（例如给你的组织中最重要的人一份）。建议使用多个存储服务以提高数据安全性。  
* 使用 SCP（SSH 的一部分）将你的快照传输到远程服务器。这是一条相当简单且安全的路线：在离你很远的地方获取一个小型 VPS，安装 ssh，然后生成一个没有密钥的 ssh 客户端密钥，然后将其添加到你的小型 VPS 的 `authorized_keys` 文件中。你现在可以自动地传输备份。为了获得最好的结果，至少在两个不同的提供商中获取两个 VPS。 

重要的是要明白，如果没有正确实施，这个系统很容易失败。至少，确保在传输完成后，你能够验证文件大小（应该与你复制的文件大小匹配），并可能验证 SHA1 摘要，如果你使用的是 VPS。  

如果出于某种原因无法传输新的备份，你还需要一种独立的警报系统。  
