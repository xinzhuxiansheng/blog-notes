
## 隐式转换和隐式参数

### 背景
`在自己的代码和别人类库之间存在一个根本的差异：可以按照自己的意愿修改或扩展自己的代码，而如果想用别人的类库，则通常只能照单全收`。编程语言中涌现出一些语法结构来缓解这个问题。Ruby有模块，而Smalltalk允许包添加来自其他包的类，这些特性功能强大但同时也很危险，你可以对整个应用程序修改某个类的行为，而你可能对于这个应用程序的某些部分并不了解。C#3.0提供了静态扩展方法，这些方法更局部但同时限制也很多，只能对类添加方法而不是字段，并且并不能让某个类实现新的接口。  

Scala对这个问题的答案是隐式转换和隐式参数。这些特性可以让已有的类库用起来更舒心，允许省掉那些冗余而明显的细节，这些细节通常让代码中真正有趣的部分变得模糊和难以理解。只要使用得当，这将会带来更专注与程序中有趣、重要部分的代码。   

### 隐式转换

**典型的使用示例**  
隐式转换通常在处理两个在开发时完全不知道对方存在的软件或类库时非常有用,它们各自都有自己的方式来描述某个概念， 而这个概念本质上是同一件事。隐式转换可以减少从一个类型显式转换成另一个类型的需要。        

Java包含了一个名为Swing的类库来实现跨平台的用户界面。Swing做的事情之一是处理来自操作系统的事件， 将它们转换成平台独立的事件对象，并将这些事件传给被称为事件监听器的应用代码。       

如果Swing在编写时知道Scala的存在，事件监听器可能可以通过函数类型来表示。这样调用者就可以用函数字面量的语法来更轻量地给出对于某类特定的事件应该做什么处理。由于Java并没有函数字面量，Swing使用了仅次于它的实现了单方法接口的内部类。对动作监听器而言，这个接口是ActionListener。   

如果没有隐式转换，使用到Swing的Scala程序就必须像Java那样使用内部类。这里有一个创建按钮并挂上一个动作监听器的例子。 每当按钮被按下，这个动作监听器就会被调用，打印出字符串 "pressed！"： 
```java
val button = new JButton
button.addActionListener(
    new ActionListener
        def actionPerformed(event: ActionEvent) ={ 
            println("pressed!")
        }
    }
)
```
这段代码当中有大量不增加有用信息的样板代码。 这个监听器是一个ActionListener，回调方法的名称为actionPerformed，以及人参是一个  ActionEvent，这些信息对于任何传给addActionListener的人参而言都是不言而喻的。 这里唯一的新信息是要被执行的代码 也就是对 println的调用。这段代码的读者需要拥有一只鹰眼来从噪声中找到真正有用的信息。 

`使用Scala改造` 

对Scala更友好的版本应该接收函数作为人参，大幅地减少样板代码：
```scala
button. addActionListener（//类型不匹配
    (__:ActionEvent)=> println("pressed!")
)
```

按目前这样的写法，这段代码并不能正常工作。addActionListener方法想要的是一个动作监听器，而我们给它的是一个函数。而通过隐式转换，这段代码是可行的。 以下是改造流程:   

第一步是编写一个在这两个类型之间的隐式转换。这里有一个从函数到动作监听器的隐式转换：
```scala
implicit def function2ActionListener(f: ActionEvent => Unit)= new ActionListener {
    def actionPerformed(event: ActionEvent)= f(event)
}
```

这个单参数方法接收一个函数并返回一个动作监听器。就跟其他单参数方法一样，它可以被直接调用并将结果传给另一个表达式：
```scala
button addActionListener(
    function2ActionListener(
        (_:ActionEvent)=> println("pressed!")
    )
)
```
相比前面内部类的版本，这已经是一个进步了。`注意那些样板代码被一个函数字面量和方法调用替换掉了`。不过，用隐式转换的话，还能做得更好。由于function2ActionListener被标记为隐式的，可以不用写出这个调用，编译器会自动插人。结果如下：
```scala
//现在可以了
button. addActionListener(
    (_:ActionEvent) => println("pressed!")
)
```


> 这段代码之所以可行，编译器首先会照原样编译，不过会遇到一个类型错误。在放弃之前，它会查找一个能修复该问题的隐式转换。在本例中，编译器找到了function2ActionListener。它会尝试这个隐式转换，发现可行，就继续下去。编译器在这里工作很卖力，这样开发者就可以多忽略一个烦琐的细节。动作监听器？动作事件函数？都行：哪个更方便就选哪个。   


### 隐式规则
