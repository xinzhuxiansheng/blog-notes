**正文**


## offset提交

在消费者消费消息的过程中 ，提交offset的时机显得非常重要，因为它决定了消费者故障重启后的消费位置；
在开发中我们通过将 enable.auto.commit选项设置为true可以起到自动提交offset的功能，auto.commit.interval.ms选项则设置了自动提交的时间间隔，这是最简单的提交offset方式。每次在调用KafkaConsumer.poll()方法时都会检测是否需要自动提交，并提交上次poll()方法返回的最后一个消息的offset。为了避免消息丢失，建议poll()方法之前要处理完上次poll方法拉取的全部消息。


要想实现"Exactly once" 语义
1. 每个分区只有一个生产者写入消息，当出现异常或超时的情况时，生产者就要查询此分区的最后一个消息，用来决定后序操作是消息重传还是继续发送
2. 为诶个消息添加一个全局唯一逐渐，生产者不做其他特殊处理，按照之前分析方式进行重传，由消费者对消息进行去重，实现"Exactly once" 语义




## poll(final Duration timeout)
1. timeout参数用来控制poll()方法的阻塞时间，在消费者的缓冲区里面没有可用数据时会发生阻塞。
2. timeout的设置取决于应用程序对响应速度的要求，比如需要在多长时间内将控制权移交给执行轮询的应用线程。可以直接将timeout设置为0，这样poll()方法会立刻返回，而不管是否拉取到了消息。如果应用线程唯一的工作就是从kafka中拉取并消费消息，则可以将这个参数设置为最大值Long.MAX_VALUE.
3. 在每次调用poll()方法时，它返回的是还没有被消费过的消息集，要做到这一点，就需要记录上一次消费时的消费位移。并且这个消费位移必须做持久化保存，而不是单单保存在内存中，否则消费者重启之后就无法知晓之前的消费位移。