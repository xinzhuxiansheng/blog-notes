## Flink State 传统有状态计算方案应用于大数据场景时存在的3个问题        

### 引言    
在 Flink 诞生之前，有状态计算的应用已经出现，并且在生活中非常常见，为什么 Flink 能把有状态计算作为自己的“王牌武器”呢？ Flink 的有状态计算到底厉害在哪里 ？      

任何新技术的诞生都源于“旧技术”无法解决当前应用场景下的新问题，而 Flink 有状态计算的诞生过程也不例外，要想回答上述问题，就要从下面这个问题讲起： 为什么传统的有状态计算方案不能应用到大数据流处理场景中？  

首先我们以Flink 诞生之前就很常见的传统事务型应用为例，通过会将状态存储在关系型数据库（例如 MySQL 中），后端应用在执行有状态计算时，会通过网络通信访问和更新数据库中的状态数据，计算并输出结果。 

如果在“大数据流”处理场景中采用事务型应用的有状态计算方案，就会出现以下3个问题。   
* 状态访问性能差    
* 异常容错成本高    
* 状态接口易用性差      

### 状态访问性能差      
相比传统事务型应用的场景，在大数据流处理领域的场景中，每个 Flink 作业需要处理的数据量都是非常庞大，数据处理的峰值吞吐量可以达到每秒百万条甚至千万条。如果 Flink 选择将状态数据存储在数据库中，并通过网络去访问，就会出现大量的网络I/O请求。 执行一次网络 I/O 请求至少是毫秒级别的响应延迟，那么在大数据量处理场景中，就会导致数据处理的高延迟和低吞吐，状态访问性能不佳。       

### 异常容错成本高  
无论在哪种数据处理场景中，我们都需要重点关注网络连接问题或者机器硬件故障导致的作业宕机问题，这些问题往往会导致数据不一致。 为了解决数据不一致的问题，我们通常会选择编写复杂的容错性代码实现数据处理的准确一次。我们先对异常容错时数据处理的精确一次做一个简单的解释： 数据处理的精确一次要求作业在发生故障时做到数据处理的不重复、不丢失，从而保证状态值既不会算多也不会算少，最终计算得到的结果和没有发生故障得到的结果一致。      

在传统有状态计算方案中要实现数据处理的精确一次，最常用的方法是利用事务访问和更新数据库。事务这种异常容错方式的开发成本不但高，而且由于要考虑的异常场景很多，因此无法保证数据处理的精确一次， 如果 Flink 使用传统事务型应用的有状态计算方案，将会使异常容错的成本变得很高。          

### 状态接口易用性差    
在传统事务型应用的有状态计算实现方案中，不同的业务场景下我们可能会使用不同的数据库来存储状态数据，比如 MySQL、Redis、HBase 等。 那么用户就要同时学习并使用每种数据库提供的接口，这对于用户来说这也是一个不低的成本。除此之外，当存储状态的数据库选型发生变化时，用户不但要去修改作业代码，将代码中访问、更行状态的接口替换为新的数据库提供的接口，还需要考虑如何将状态数据从一个数据库迁移到另一个数据库中。因此，如果 Flink 使用传统事务型应用的有状态计算方案，状态接口会很不易用。       

### Flink 实现有状态计算的思路  
* 针对状态访问性能差的问题：通过状态本地化、持久化实现极致的状态访问速度。     
* 针对异常容错成本高的问题：通过精准一次的一致性快照实现低成本的异常容错。  
* 针对状态接口易用性差的问题：通过统一的状态接口提升状态的易用性。          




refer   
1."Flink SQL 与 DataStream：入门、进阶与实战"           