## Flink SQL 双流 Join 介绍

### 背景    
在实际工作中进行流数据处理的时候 较多业务场景需要构建宽表。此时就需要对多张表实现Join操作,那我们大家提到离线数据Join点也不慌，感觉很简单。主要是因为离线数据在Join之前，数据都已经全部到了，所以说在做数据关联的时候就很简单了,不需要考虑数据变化的情况。   

但是针对流数据的Join，心里面就没底了，因为数据都是实时产生的，两个数据流在Join的时候,数据都是无界的 这样就会出现一些问题。举个例子: 假设有两个数据流: A流和B流。
* 第一个问题: A流和B流里面数据到达时机不一样 会导致两个数据流里面相同关联条件的数据关联不上     
* 第二个问题: A流中的数据到达了,但是B流中相同关联条件的数据一直没到 那A流中的数据是一直等待? 还是使用null补全数据下发?      
这两个问题其实对应的就是数据质量和数据延迟。如何均衡考虑数据质量和数据延迟是双流Join需要解决的问题。这些问题FlinksQL中的双流Join提供有对应的解决方案。      

下面我们以Hive SQL离线Join和Fink SQL双流Join来对比分析加深我们对Flink SOL 双流Join的理解。  

**Hive SQL离线Join VS Flink SQL双流Join**
|       |    Hive SQL离线Join | Flink SQL双流Join  |
| :-------- | --------:| :-----: |
| 数据源  | 有界（离线数据） |  无界（实时数据）   |
| 计算次数     |   一次 |  持续计算  |
| 计算结果     |   有界（离线数据） | 无界（实时数据）  |
| 计算驱动     |   单边驱动 | 双边驱动  |

我们会通过数据源、计算次数、计算结果和计算驱动这几个角度进行对比分析, 离线数据都是有界的。Flink SQL双流Join计算的是实时产生的数据,实时数据是无界的 ,当然了 Flink SOL也可以计算HDFS中的离线数据, 只不过我们在这里分析的是Flink SQL中实时数据的Join。 
* 计算次数：Hive SQL离线Join只需要执行一次就可以计算出最终的结果, 而Flink SQL双流Join会随着实时数据的产生,持续不断的进行计算。  
* 计算结果：Hive SOL离线Join只会执行一次计算，所以产生的结果是有界的，而Flink SQL 双流Join会随着实时数据的产生。持续不断的进行计算，所以最终的结果是无界的。       
* 计算驱动：Hive SQL离线Join可以认为是单边驱动。而Flink SQL双流Join属于双边驱动，也可以称之为双流驱动怎么理解呢？   

兩份离线数据进行Join。 只需要拿其中一份离线数据主动去和另外一份离线数进行关联,即可获取到最终结果但是针对两份数据流进行Join, 由于两份数据流的速度不一样，会号致第一份数据流中的数据已经到了, 但是第二份数据流中的数据还没有到，或者是第二份数据流中的数据已经到了，但第一份数据流中的数据还没到。所以在实现Join需求时,需要对两份数据流分别进行保存，当第一份数据流中的数据到了, 他会主动到第二份数据流中进行关联, 当第二份数据流中的数据到了,他也会主动到第一份数据流中进行关联，这样动能保证 Join 的语义。  

所以说Flink SOL双流Join属于双边驱动。       










